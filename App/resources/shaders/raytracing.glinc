// Depth texture always bound to sampler slot 0
layout(binding = 0) uniform sampler2D u_DepthTexture;
layout(binding = 1) uniform usampler3D u_ShadowMap;
layout(binding = 9) uniform sampler2D u_BlueNoiseTexture;

uniform mat4 u_InverseView;
uniform mat4 u_InverseProjection;
uniform int u_FrameNumber;

const float g_BaseVoxelScale = 0.1f;
const float g_ShadowLODScales[3] = float[3](g_BaseVoxelScale, g_BaseVoxelScale * 2.0f, g_BaseVoxelScale * 4.0f);
const int g_ShadowLODDistances[3] = int[3](3, 5, 8);

const float g_PI = 3.14159265358f;
const float g_GoldenRatio = 1.61803398875f;

vec2 GetBlueNoise2D(ivec2 pixel, int frame, int sampleIndex)
{
	ivec2 offset = ivec2(
		frame * 59 + sampleIndex * 73,
		frame * 157 + sampleIndex * 197
	);
	ivec2 noiseCoord = (pixel + offset) & 511;
	vec4 noise = texelFetch(u_BlueNoiseTexture, noiseCoord, 0);
	return noise.gb; // two channels for better decorrelation
}

vec3 RandomDirectionOnHemisphere(vec3 normal, ivec2 pixel, int frame, int sampleIndex)
{
	vec2 n = GetBlueNoise2D(pixel, frame, sampleIndex);
	float r0 = n.x, r1 = n.y;

	// Add both temporal and sample-based offsets
	float temporalOffset = float(frame) * g_GoldenRatio;
	float sampleOffset = float(sampleIndex) * 0.618034; // 1/phi for even distribution
	r0 = fract(r0 + temporalOffset + sampleOffset);

	float cosTheta = sqrt(1.0 - r1);
	float sinTheta = sqrt(r1);
	float phi = 2.0 * g_PI * r0;

	float x = sinTheta * cos(phi);
	float y = sinTheta * sin(phi);
	float z = cosTheta;

	vec3 up = abs(normal.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
	vec3 tangent = normalize(cross(up, normal));
	vec3 bitangent = cross(normal, tangent);

	return normalize(x * tangent + y * bitangent + z * normal);
}

bool RaycastShadowMapVariableFidelity(vec3 origin, vec3 direction, out float t, const int maxDistanceMeters, const int mipLevel)
{
	const float voxelScale = g_ShadowLODScales[mipLevel];
	ivec3 mapDimensions = textureSize(u_ShadowMap, mipLevel);

	vec3 worldspaceExtents = (mapDimensions * voxelScale) / 2.0f;
	vec3 boundsMin = -worldspaceExtents;

	vec3 voxelsPerUnit = vec3(1.0f / voxelScale);
	
	vec3 entry = (origin - boundsMin) * voxelsPerUnit;
	vec3 step = sign(direction);
	vec3 delta = abs(1.0f / direction);
	ivec3 pos = ivec3(clamp(floor(entry), vec3(0.0f), vec3(mapDimensions - 1)));
	vec3 tMax = (vec3(pos) - entry + max(step, 0.0)) / direction;

	int maxSteps = int(maxDistanceMeters / voxelScale);
	ivec3 iStep = ivec3(step);

	// early exit
	if (any(lessThan(pos, ivec3(0))) || any(greaterThanEqual(pos, mapDimensions))) {
		t = float(maxDistanceMeters);
		return false;
	}

	for (int i = 0; i < maxSteps; i++) {
		if (texelFetch(u_ShadowMap, pos, mipLevel).r != 0) {
			// Find which axis we just crossed
			int axis = (tMax.x < tMax.y) ? ((tMax.x < tMax.z) ? 0 : 2) : ((tMax.y < tMax.z) ? 1 : 2);
			t = (tMax[axis] - delta[axis]) * voxelScale;
			return true;
		}

		// branchless min select
		bvec3 mask = lessThan(tMax.xyz, tMax.yzx);
		mask = mask && lessThanEqual(tMax.xyz, tMax.zxy);

		pos += ivec3(mask) * iStep;
		tMax += vec3(mask) * delta;

		// exit map?? :(
		if (any(lessThan(pos, ivec3(0))) || any(greaterThanEqual(pos, mapDimensions))) {
			break;
		}
	}

	t = float(maxDistanceMeters);
	return false;
}

vec3 ReconstructWorldSpaceFromDepth(vec2 uv)
{
	float depth = texture(u_DepthTexture, uv).r;

	float z = depth * 2.0f - 1.0f;
	vec4 ndcPosition = vec4(uv * 2.0f - 1.0f, z, 1.0f);  // x, y in [-1, 1], z in [-1, 1]
	vec4 cameraSpacePosition = u_InverseProjection * ndcPosition;
	cameraSpacePosition /= cameraSpacePosition.w;

	vec4 worldPos = u_InverseView * cameraSpacePosition;
	return worldPos.xyz / worldPos.w;
}